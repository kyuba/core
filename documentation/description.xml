<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<article lang="en" class="whitepaper" xmlns="http://docbook.org/ns/docbook"
         version="4.5">
 <articleinfo>
  <date>2008-07-09</date>
  <title>Kyuuba</title>
  <authorgroup>
   <author>
    <firstname>Magnus</firstname>
    <surname>Deininger</surname>
   </author>
  </authorgroup>
  <copyright>
   <year>2008</year>
   <holder>Magnus Deininger</holder>
  </copyright>

  <abstract>
   <para>Kyuuba is an init programme for POSIX-ish systems, that is intended to
    replace the current de-facto standard SysV-style and BSD-style init
    programmes.</para>
   <para>Design goals include complete independence of shell scripts, speed,
    small memory and on-disk footprints, portability (it should run on at least
    Linux, *BSD, Darwin and all applicable parts should run on Windows),
    flexibility and it should aid in virtualisation and service jailing.</para>
  </abstract>
</articleinfo>

 <section id="introduction">
  <title>Introduction</title>

  <para>
   Kyuuba isn't a completely new programme, actually it's a redesign and rewrite
   of eINIT. eINIT was, and still is, modular and fast, but we hit a good deal
   of obstacles that can't be fixed due to the original design, and at the same
   time due to nobody really enforcing that original design.
  </para>
  <para>
   A lot of the basic goals for kyuba have thus been influenced by eINIT and the
   experience we've gotten with that. Our goals are:
  </para>
  <variablelist>
   <varlistentry>
    <term>Speed</term>
    <listitem><para>Computers should boot fast, and there is absolutely no
     reason to have them boot slow like they do these days. This is especially
     important for any embedded application and for things like backup servers
     that shouldn't be running all the time, but that need to be able to get
     online as fast as possible. For these applications, slow bootup times
     are generally annoying and often make the manufacturer of the device look
     unprofessional.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>Small Size (Memory- and On-Disk)</term>
    <listitem><para>Init programmes usually need to run at all times, thus they
     count against the available RAM at all times. For that reason, an init
     should be as small as possible so that the programmes it initialises have
     as much ram available to them as possible.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>Parallelisation</term>
    <listitem><para>A lot of time in the boot process is spent waiting on other
     processes to do something. Doing nothing while waiting is generally a bad
     thing to do if we want the whole bootup process to be fast, especially
     considering that some tasks always take time, such as getting an IP address
     via DHCP.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>Modularity</term>
    <listitem><para>Our goal is to get a core application with a 1.0 release out
     as fast as possible, but we can't possibly foresee all the potential
     applications of this programme beforehand. For this reason, we need a
     strong module interface, so that extra functionality can easily added to
     the core, without modifying the core.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>No Shell Scripting</term>
    <listitem><para>Shell scripts are slow, but they're handy. For this reason,
     shell scripting is still extremely popular among Unix veterans. But just
     because shell scripting is handy, and it's perceived as one way to add
     flexibility, it isn't the only way to add flexibility. With a properly
     designed client library, even C should be easy enough to use to cover the
     typical applications of Shell Scripting in the bootup process.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>No 'real' Threading</term>
    <listitem><para>The first few versions of eINIT relied on heavy threading,
     but that turned out to create a lot of problems. Eventually the overhead of
     threading made that approach slower than a custom "green thread"
     implementation that we tried in a few unreleased versions.</para>
    <para>Green threads as well as message-passing style threads should suffice
     for our applications, since there are no calculations that could benefit
     from multi-processing, and most of time init is only supposed to spawn
     a number of other processes in the right order.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>Service Supervision</term>
    <listitem><para>We think that supervising running services is exactly the
     type of thing that an init programme should be doing. If a service dies for
     some reason, oftentimes users will want that service to respawn as fast as
     possible, or they want some other actions to be taken, and since init needs
     to supervise all processes anyway, this is exactly the type of thing it
     should be doing at the same time.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>Proper handling of unexpected Situations</term>
    <listitem><para>If a daemon fails to start, there's often alternative
     daemons that may take its place; for example if a user is only interested
     in a graphical login screen and using the computer with a GUI, and after
     updating his gnome installation for some reason gdm keeps failing, the user
     will probably prefer a kdm or slim login screen instead of a text mode
     prompt, which would leave him with a plain shell after entering his login
     data instead of some GUI the user is actually used to.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>No need to follow legacy Examples</term>
    <listitem><para>One of the things that severely hurt eINIT was that we tried
     to keep all the legacy applications working. While this will still be
     possible with a properly modular design, we made the mistake of doing this
     right from the start instead of just adding it afterwards. This resulted
     in a lot of confusion with both the users and developers as to what
     behaviour can be expected in some circumstances.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>Portability</term>
    <listitem><para>Even though the init programme is normally considered to be
     one of the prime examples of a system-dependant application, we'd like to
     make sure that this programme will run on all the usual operating systems:
     *BSD, Linux, Darwin, hopefully also Windows (at least some portions of
     kyuuba should run perfectly fine on Windows).</para></listitem>
   </varlistentry>
  </variablelist>
  <para>Additionally, the programme will be licenced under a BSD-style licence,
   which means it will be truly free, but also properly usable in a business
   setting.</para>
 </section>

 <section id="primus-components">
  <title>Kyuuba Core Components</title>

  <para>Kyuuba will be split into several components that should interact with
   each other. Splitting kyuuba into multiple programmes will help with
   reclaiming memory used by components that aren't used very often, and it
   increases stability and modularity of the whole system.</para>

  <section id="pc-atomic-libc">
   <title>C Library</title>

   <para>Even though C is perfectly suited for writing programmes that work fast
    as well as doing so with tight memory constraints, it's also notorious for
    needing quite an effort to keep the code portable. For this reason, we'll
    be writing a special C library that serves as a portability layer, as well
    as a high level abstraction layer.</para>
   <para>The library is written in such a way that it is easily made
    freestanding, that is, so that it won't require the host libc, in order to
    reduce memory use. It's also designed to only support the functions kyuuba
    will be needing.</para>
   <para>Work on this library has already started under codename
    <quote>Atomic LibC</quote>. The library includes almost all the features
    we'll be needing, and the freestanding variants turned out to be
    significantly smaller than most of the host libcs we compared it against.
    (typically about 16k in statically linked amd64 binaries vs. about
    300-600k).</para>
  </section>

  <section id="pc-monitor">
   <title>The Monitor</title>

   <para />
  </section>

  <section id="pc-coordinator">
   <title>The Coordinator(s)</title>

   <para />
  </section>

  <section id="pc-servers">
   <title>Servers</title>

   <para />
  </section>

  <section id="pc-ipc">
   <title>The IPC System</title>

   <para />
  </section>
 </section>

 <section id="secundus-service-model">
  <title>Service Model</title>
  <para />

  <section id="ssm-dependencies">
   <title>Dependency Types</title>

   <para />
  </section>
 </section>

 <section id="tertius-os-requirements">
  <title>OS Requirements</title>
  <para />

  <section id="tor-initramfs">
   <title>Initramfs</title>

   <para />
  </section>

  <section id="tor-fs-layout">
   <title>FS Layout</title>

   <para />

   <section id="torfl-general-layout">
    <title>General Layout</title>

    <para />
   </section>

   <section id="torfl-libraries">
    <title>Library Locations</title>

    <para />
   </section>
  </section>
 </section>

 <section id="quartus-module-interface">
  <title>Module Interface</title>

  <para />

  <section id="qmi-shared-objects">
   <title>Shared Objects</title>

   <para />
  </section>

  <section id="qmi-static">
   <title>Statically Linked Modules</title>

   <para />
  </section>

  <section id="qmi-hubs">
   <title>Module Hubs</title>

   <para />
  </section>
 </section>
</article>
